int main(void){
  (*((volatile unsigned char* )0x2A))|=(0x1<<4);
  (*((volatile unsigned char* )0x2A))|=(0x1<<5);

  for(;;){
    (*((volatile unsigned char* )0x2B))|=(0x1<<4);    //         0001 0000
    (*((volatile unsigned char* )0x2B))&=(~(0x1<<5));//0010 0000~1101 1111
  }
  return 0;
}
/*
「0x2A」：これはDRDDというレジスタのメモリｱﾄﾞﾚｽ。
各ピンが入力か出力かを設定する為のﾚｼﾞｽﾀ
DDROは何の略でしょうか？
ATmega328Pのレジスタはどのくらいの大きさがあり、
それぞれにどんなｱﾄﾞﾚｽが振り分けられている。
valatileを調べましたが、揮発性という意味なのですね。
なぜこの変数名を使っているのでしょうか？
|=(0x1 << 4)：1を左に4ビットシフトする意味なので
0000 0001
0001 0000　ビット4（0から数える）だけが1ビットのデータ
ビットマスクとは？
|=は+=と同じように演算子の右側の演算をした結果を地震に代入するということだと思うのですが、
この場合は0x2A、つまり0010 1010と0001 0000のOR演算をしてその結果を0x2A自身に書き込む
ということ？

「volatile」の語源や由来、核となるイメージ、日本で馴染みのある関連のある単語は？
これが付くと「予期せず変更される可能性がある」という意味になる。
マイコンのﾚｼﾞｽﾀはCPUが指示せずともタイマや外部状況などで切り替わることがある。
「volatile」が付くと、コンパイラに対して、
「この変数はいつ変わるか分からないから、
『毎回必ずメモリ(orﾚｼﾞｽﾀのｱﾄﾞﾚｽ)から値を読み直してね！』最適化とかで省略しないでね」
と指示する役割になる。※コンパイラはこれが無いとさっき読み込んだ変数名と同じだから、
さっきと値も同じはずだとして処理を進めてしまう。
volatileはフランスのボルテールと同じ？
またこれは修飾子という分類？→型修飾子という分類。constと同じ分類。

なぜキャスト(volatile unsigned char*)が必要なのか。
0x2Aは、人にとってはDDRDﾚｼﾞｽﾀのｱﾄﾞﾚｽと分かるが、
コンパイラにとっては**唯の数値**に過ぎない。
そのため、(volatile unsigned char*)で符号なし1バイト整数が置かれている場所=ｱﾄﾞﾚｽとして
扱いなさいという指示のためのキャスト。なぜ整数なのにcharなのだっけ？忘れてしまった。
⇒char型は必ず「１バイト」のサイズを持つことが保証されている唯一の型だから。
なので、１バイト単位で正確にｱﾄﾞﾚｽを指し示すことが出来る。
intではコンパイラやCPUによってサイズが異なることがあり、指す場所が変わってしまうことある
最後に囲った()と間接参照を示す*で、0x2Aが指すメモリの中身にアクセスしなさいという意味。
for(;;)この書き方初めてみたけれど、許されるの？
⇒無限ループを作るための一般的な書き方の一つ。
while(1)との使い分けはどのように行われている？⇒機能的な違いは全く無い。

&演算子を使う理由
⇒元の値を残しつつ、０にしたい箇所を絶対に０にする。
&= ~マスク の形を使うことで、「マスクで指定したビットだけを0にし、
それ以外のビットは元の状態を保つ」ことができる。
*/
