void setup() {
  bitSet(DDRC,PC3);//DataDirectionRegisterCにCポート3番ピン＝26番ピンに
  //に対応するレジスタに1bitを立てる
  //＝ポートを出力として使用することを設定。bit’S’etでSが大文字なことに注意。
  bitClear(DDRD,PD2);//Dポート(2～6番、11～13番端子)の2番ピン＝4番端子
  //(0番から数え始める)に対応するレジスタのbitを0に＝入力として使用設定。
  bitSet(PORTD,PD2);//モードをインプットにしてPORTX(ポートから出力するモード
  //(0でLow、1でHigh))を設定するレジェンド立てることで内部プルアップ抵抗をONにする。
  //どうやって小さいマイコンで内部抵抗を高くしている？→内部のMOSの回路をとても狭く
  //＝電子が通りにくい＝抵抗値が高くなるようにして実現しているのだっけ？
  bitClear(EICRA,ISC00);
  bitSet(EICRA,ISC01);//発音「アイクラ」、ExterbalInterruptControlRegisterA
  //(外部割込制御レジスタ)のISC01(InterruputSenseControlビット)割込感覚制御ビット
  //に1bitを立てることでISC01,02が(1,0)となりINT2ピンのHigh→Lowの立下り変化＝
  //ON→OFFで外部割り込みが発生する様になる。INT1の時はISC10と11。INT0,1ピンは
  //4番5番端子＝PD2,PD3。外部割込みピンはATmega328P全体で2端子しか用意されていない。
  //PCINTnはピン変化割り込み、ピンの電圧レベルの変化で起動。23本？数が多い。
  //INTnピンとPCINTnピンはどう使分ける？2つの使い分けがいまいち理解できていない。
  //→PCINTnピンはHigh⇔Low程度の変化しか検知できず。どのピンがどう変化したかは、
  //後からプログラム内で記述して調べる必要がある。
  bitSet(EIMSK,INT0);//EnableInterruptMasKRegister外部割込許可(マスク)レジスタ
  //割込みを「有効にする」「無効にする」をそれぞれ「マスクしない」「マスクする」
  //と呼ぶ。ややこしいけれど、有効にする＝1bitを立てるは変わらないので。
  //EIMSKレジスタのINT0ビットに1bitを立てることでINT0の外部割込みが有効に
  bitClear(PORTC,PC3);//Cポート3番ピン＝26番ピンの出力を0に(初期化)
}

void loop() {}

ISR(INT0_vect){//ISR＝InterruputServiceRoutine＝割込サービスルーチン
//（割込みイベントハンドラとして実行するルーチン）。ハンドラ＝対応係の様なもの。
//つまり割込みを通知するイベントが発生した時に実行する何度も実行されるプログラム。
//ATmega328Pでは割込み通知するイベント名が設定されていて、その中の番号２番が
//INT0_vect。これが起動するとEIFRレジスタのINTF0ビットにフラグ(1)が立つ。
  PORTC^=(0x1<<PC3);//Cポート3番ピンに1を立てる＝4番目のビットに1、00001000、
  //これと現在のCポートの状態0000x000の排他的論理和つまり、0000 0000なら1点灯、
  00001000なら0消灯と呼び出される度に点灯と消灯を切り替える動作になる。
}
